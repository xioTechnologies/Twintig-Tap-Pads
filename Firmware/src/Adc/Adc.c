/**
 * @file Adc.c
 * @author Seb Madgwick
 * @brief ADC driver.
 */

//------------------------------------------------------------------------------
// Includes

#include "Adc.h"
#include "definitions.h"
#include "Fifo.h"
#include "Timer/Timer.h"

//------------------------------------------------------------------------------
// Definitions

/**
 * @brief Oversampling factor. An oversampling factor of 64 is equivalent to an
 * extra 3 bits of resolution.
 */
#define OVERSAMPLING (64)

/**
 * @brief Scaling for 12-bit resolution.
 */
#define SCALING (1.0f / ((float) OVERSAMPLING * 4095.0f))

/**
 * @brief Accumulator.
 */
typedef struct {
    uint32_t numberOfSamples;
    uint32_t ch1;
    uint32_t ch2;
    uint32_t ch3;
    uint32_t ch4;
    uint32_t ch5;
    uint32_t ch6;
    uint32_t ch7;
    uint32_t ch8;
} Accumulator;

/**
 * @brief FIFO packet.
 */
typedef struct {
    uint64_t timestamp;
    uint32_t ch1;
    uint32_t ch2;
    uint32_t ch3;
    uint32_t ch4;
    uint32_t ch5;
    uint32_t ch6;
    uint32_t ch7;
    uint32_t ch8;
} __attribute__((__packed__)) FifoPacket;

//------------------------------------------------------------------------------
// Variables

static uint8_t fifoData[100 * sizeof (FifoPacket)];
static Fifo fifo = {.data = fifoData, .dataSize = sizeof (fifoData)};
static volatile uint32_t bufferOverflow;

//------------------------------------------------------------------------------
// Functions

/**
 * @brief Initialises the module. This function must only be called once, on
 * system startup.
 */
void AdcInitialise(void) {

    // Load calibration
    ADC7CFG = DEVADC7;

    // Configure ADC control registers
    ADCCON1bits.STRGSRC = 0b00001; // global software edge trigger (GSWTRG)
    ADCCON1bits.AICPMPEN = 0; // analog input charge pump is disabled

    // ADC7 timing
    ADCCON2bits.ADCDIV = 8; // TAD = 16 * TQ
    ADCCON2bits.SAMC = 16; // 18 TADx

    // Warm up timing
    ADCANCONbits.WKUPCLKCNT = 5;

    // Enable inputs for common scan
    ADCCSS1bits.CSS7 = 1;
    ADCCSS1bits.CSS8 = 1;
    ADCCSS1bits.CSS9 = 1;
    ADCCSS1bits.CSS10 = 1;
    ADCCSS1bits.CSS11 = 1;
    ADCCSS1bits.CSS12 = 1;
    ADCCSS1bits.CSS13 = 1;
    ADCCSS1bits.CSS14 = 1;

    // Set scan as trigger source
    ADCTRG2bits.TRGSRC7 = 0b00011;
    ADCTRG3bits.TRGSRC8 = 0b00011;
    ADCTRG3bits.TRGSRC9 = 0b00011;
    ADCTRG3bits.TRGSRC10 = 0b00011;
    ADCTRG3bits.TRGSRC11 = 0b00011;

    // Enable ADC
    ADCCON1bits.ON = 1;

    // Wait for voltage reference
    while (ADCCON2bits.BGVRRDY == 0);

    // Wake up ADC
    ADCANCONbits.ANEN7 = 1;

    // Wait for ADC to wake up
    while (ADCANCONbits.WKRDY7 == 0);

    // Enable digital ADC
    ADCCON3bits.DIGEN7 = 1;

    // Configure end of scan interrupt
    ADCCON2bits.EOSIEN = 1; // Interrupt will be generated when EOSRDY bit is set
    EVIC_SourceStatusClear(INT_SOURCE_ADC_EOS);
    EVIC_SourceEnable(INT_SOURCE_ADC_EOS);

    // Trigger first conversion
    ADCCON3bits.GSWTRG = 1;
}

/**
 * @brief ADC interrupt handler.  This function should be called by the ISR
 * implementation generated by MPLAB Harmony.
 */
void AdcInterruptHandler(void) {
    static Accumulator accumulator;
    accumulator.numberOfSamples++;
    accumulator.ch1 += ADCDATA10;
    accumulator.ch2 += ADCDATA9;
    accumulator.ch3 += ADCDATA8;
    accumulator.ch4 += ADCDATA7;
    accumulator.ch5 += ADCDATA14;
    accumulator.ch6 += ADCDATA13;
    accumulator.ch7 += ADCDATA12;
    accumulator.ch8 += ADCDATA11;
    if (accumulator.numberOfSamples >= OVERSAMPLING) {
        const FifoPacket fifoPacket = {
            .timestamp = TimerGetTicks64(),
            .ch1 = accumulator.ch1,
            .ch2 = accumulator.ch2,
            .ch3 = accumulator.ch3,
            .ch4 = accumulator.ch4,
            .ch5 = accumulator.ch5,
            .ch6 = accumulator.ch6,
            .ch7 = accumulator.ch7,
            .ch8 = accumulator.ch8,
        };
        if (FifoWrite(&fifo, &fifoPacket, sizeof (fifoPacket)) != FifoResultOk) {
            bufferOverflow++;
        }
        static const Accumulator zeros;
        accumulator = zeros;
    }
    ADCCON2bits.EOSRDY = 0; // clear status bit else interrupt will persist
    EVIC_SourceStatusClear(INT_SOURCE_ADC_EOS);
    ADCCON3bits.GSWTRG = 1; // trigger next conversion
}

/**
 * @brief Gets data.
 * @param data Data.
 * @return Result.
 */
AdcResult AdcGetData(AdcData * const data) {
    FifoPacket fifoPacket;
    if (FifoRead(&fifo, &fifoPacket, sizeof (fifoPacket)) == 0) {
        return AdcResultError;
    }
    data->timestamp = fifoPacket.timestamp;
    data->ch1 = (float) fifoPacket.ch1 * SCALING;
    data->ch2 = (float) fifoPacket.ch2 * SCALING;
    data->ch3 = (float) fifoPacket.ch3 * SCALING;
    data->ch4 = (float) fifoPacket.ch4 * SCALING;
    data->ch5 = (float) fifoPacket.ch5 * SCALING;
    data->ch6 = (float) fifoPacket.ch6 * SCALING;
    data->ch7 = (float) fifoPacket.ch7 * SCALING;
    data->ch8 = (float) fifoPacket.ch8 * SCALING;
    return AdcResultOk;
}

/**
 * @brief Returns the number of samples lost due to buffer overflow. Calling
 * this function will reset the value.
 * @return Number of samples lost due to buffer overflow.
 */
uint32_t AdcBufferOverflow(void) {
    return __sync_lock_test_and_set(&bufferOverflow, 0);
}

//------------------------------------------------------------------------------
// End of file
